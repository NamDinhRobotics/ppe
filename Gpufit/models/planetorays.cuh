#ifndef GPUFIT_PLANETORAYS_CUH_INCLUDED
#define GPUFIT_PLANETORAYS_CUH_INCLUDED

/* Description of the calculate_linear1d function
* ===================================================
*
* This function calculates the values of one-dimensional linear model functions
* and their partial derivatives with respect to the model parameters. 
*
* This function makes use of the user information data to pass in the 
* independent variables (X values) corresponding to the data.  The X values
* must be of type REAL.
*
* Note that if no user information is provided, the (X) coordinate of the 
* first data value is assumed to be (0.0).  In this case, for a fit size of 
* M data points, the (X) coordinates of the data are simply the corresponding 
* array index values of the data array, starting from zero.
*
* There are three possibilities regarding the X values:
*
*   No X values provided: 
*
*       If no user information is provided, the (X) coordinate of the 
*       first data value is assumed to be (0.0).  In this case, for a 
*       fit size of M data points, the (X) coordinates of the data are 
*       simply the corresponding array index values of the data array, 
*       starting from zero.
*
*   X values provided for one fit:
*
*       If the user_info array contains the X values for one fit, then 
*       the same X values will be used for all fits.  In this case, the 
*       size of the user_info array (in bytes) must equal 
*       sizeof(REAL) * n_points.
*
*   Unique X values provided for all fits:
*
*       In this case, the user_info array must contain X values for each
*       fit in the dataset.  In this case, the size of the user_info array 
*       (in bytes) must equal sizeof(REAL) * n_points * nfits.
*
* Parameters:
*
* parameters: An input vector of model parameters.
*             p[0]: offset
*             p[1]: slope
*
* n_fits: The number of fits.
*
* n_points: The number of data points per fit.
*
* value: An output vector of model function values.
*
* derivative: An output vector of model function partial derivatives.
*
* point_index: The data point index.
*
* fit_index: The fit index.
*
* chunk_index: The chunk index. Used for indexing of user_info.
*
* user_info: An input vector containing user information.
*
* user_info_size: The size of user_info in bytes.
*
* Calling the calculate_linear1d function
* =======================================
*
* This __device__ function can be only called from a __global__ function or an other
* __device__ function.
*
*/

__device__ void rayxpln(
  REAL const* in1,
  REAL const* in2,
  REAL const* in3,
  REAL const& r1,
  REAL const& r2,
  REAL const& r3,
  REAL const* in7,
  REAL & r,
  REAL & j1,
  REAL & j2,
  REAL & j3) {
/*
% RAYXPLN Radius of ray intersecting plane.
%   R = RAYXPLN(V1,V2,V3,R1,R2,R3,V) computes the radius R of a ray
%   intersecting a plane. The ray is defined by the direction vector V. The
%   plane is defined by the three points R1*V1, R2*V2, R3*V3. All rays
%   originate in the same point with arbitrary coordinates.
%
%   R is a scalar. V1, V2, and V3 are 3-element row vectors. V is an Nx3
%   matrix of direction vectors.
%
%   [R,J] = RAYXPLN(...) also computes the Nx3 Jacobian of R with respect
%   to R1, R2, R3.
%
%   Example:
%      [r,j] = rayxpln([1,0,0],[1,1,0],[1,0,1],3,4,5,rand(10,3))
%
%   See also LINXPLN.

% Copyright 2018 Alexander Schaefer

%    This function was generated by the Symbolic Math Toolbox version 8.1.
*/

  REAL v11 = in1[0];
  REAL v12 = in1[1];
  REAL v13 = in1[2];
  REAL v21 = in2[0];
  REAL v22 = in2[1];
  REAL v23 = in2[2];
  REAL v31 = in3[0];
  REAL v32 = in3[1];
  REAL v33 = in3[2];
  REAL v41 = in7[0];
  REAL v42 = in7[1];
  REAL v43 = in7[2];
  REAL t2 = v11*v22*v33;
  REAL t3 = v12*v23*v31;
  REAL t4 = v13*v21*v32;
  REAL t17 = v11*v23*v32;
  REAL t18 = v12*v21*v33;
  REAL t19 = v13*v22*v31;
  REAL t5 = t2+t3+t4-t17-t18-t19;
  REAL t6 = r1*r2*v11*v22*v43;
  REAL t7 = r1*r2*v12*v23*v41;
  REAL t8 = r1*r2*v13*v21*v42;
  REAL t9 = r1*r3*v11*v33*v42;
  REAL t10 = r1*r3*v12*v31*v43;
  REAL t11 = r1*r3*v13*v32*v41;
  REAL t12 = r2*r3*v21*v32*v43;
  REAL t13 = r2*r3*v22*v33*v41;
  REAL t14 = r2*r3*v23*v31*v42;
  REAL t20 = r1*r2*v11*v23*v42;
  REAL t21 = r1*r2*v12*v21*v43;
  REAL t22 = r1*r2*v13*v22*v41;
  REAL t23 = r1*r3*v11*v32*v43;
  REAL t24 = r1*r3*v12*v33*v41;
  REAL t25 = r1*r3*v13*v31*v42;
  REAL t26 = r2*r3*v21*v33*v42;
  REAL t27 = r2*r3*v22*v31*v43;
  REAL t28 = r2*r3*v23*v32*v41;
  REAL t15 = t6+t7+t8+t9+t10+t11+t12+t13+t14-t20-t21-t22-t23-t24-t25-t26-t27-t28;
  r = (r1*r2*r3*t5)/t15;
  REAL t16 = r3*r3;
  REAL t29 = 1.0/(t15*t15);
  REAL t30 = r1*r1;
  REAL t31 = r2*r2;
  j1 =  t5*t16*t29*t31*(v21*v32*v43-v21*v33*v42-v22*v31*v43+v22*v33*v41+v23*v31*v42-v23*v32*v41);
  j2 = -t5*t16*t29*t30*(v11*v32*v43-v11*v33*v42-v12*v31*v43+v12*v33*v41+v13*v31*v42-v13*v32*v41);
  j3 =  t5*t29*t30*t31*(v11*v22*v43-v11*v23*v42-v12*v21*v43+v12*v23*v41+v13*v21*v42-v13*v22*v41);
}

__device__ void calculate_planetorays(
    REAL const * parameters,
    int const n_fits,
    int const n_points,
    REAL * value,
    REAL * derivative,
    int const point_index,
    int const fit_index,
    int const chunk_index,
    char * user_info,
    std::size_t const user_info_size)
{
    // parameters:  3 plane ranges
    // data:        1 ray range (to calc chi2)
    // user info:   12 = (3 plane + 1 ray) vectors
    
    // indices

    int const chunk_begin = chunk_index * n_fits * n_points;
    int const fit_begin = fit_index * n_points; 
    REAL * vector_data = (REAL*) user_info;
    REAL * vector = vector_data + 12 * (chunk_begin + fit_begin + point_index);

    // value and derivatives

    rayxpln(
      vector + 0,
      vector + 3,
      vector + 6,
      parameters[0],
      parameters[1],
      parameters[2],
      vector + 3 * point_index,
      value[point_index],
      derivative[point_index + 0 * n_points],
      derivative[point_index + 1 * n_points],
      derivative[point_index + 2 * n_points]);
}

#endif
